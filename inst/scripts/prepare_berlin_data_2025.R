# Create data and config as required by kwb.rabimo from Berlin data delivered by
# Leilah Haag in March 2025

# Define global constants, e.g. paths ------------------------------------------
{
  PATH <- "C:/Users/hsonne/Downloads/A/abimo_hyras9120.gdb20250310/abimo_hyras9120.gdb"
  FILE_ROADS <- file.path(PATH, "a00000009.gdbtable")
  FILE_BLOCKS <- file.path(PATH, "a0000000a.gdbtable")

  # Precipitation correction factor, originally from ABIMO config file
  PRECIPITATION_CORRECTION_FACTOR <- 1.09

  URL_GREEN_ROOFS <- "https://gdi.berlin.de/services/wfs/ua_gruendaecher_2020?REQUEST=GetCapabilities&SERVICE=wfs"
  #sf::st_layers(URL_GREEN_ROOFS)
  GREEN_ROOF_LAYER <- "ua_gruendaecher_2020:e_begruente_dachfl_block"
}

# Define functions -------------------------------------------------------------
{
  library(dplyr)

  read_gdbtable <- function(file, clear_shape = TRUE) {
    data <- sf::read_sf(file)
    if (clear_shape) {
      data$Shape <- NULL
    }
    data
  }

  get_district_map <- function(berlin_data) {
    district_map <- berlin_data %>%
      dplyr::group_by(bez, bezirk) %>%
      dplyr::summarise(n = dplyr::n(), .groups = "drop") %>%
      dplyr::filter(!is.na(bezirk), n > 3L) %>%
      dplyr::arrange(bez, bezirk) %>%
      dplyr::mutate(bez = as.integer(bez)) %>%
      dplyr::select(-n) %>%
      as.data.frame()
    stopifnot(all(table(district_map$bezirk) == 1L))
    stopifnot(all(sort(district_map$bezirk) == seq_along(district_map$bezirk)))
    district_map
  }

  get_evaporation_config <- function(berlin_data, epot_data) {
    epot_not_waterbody <- dplyr::left_join(
      x = get_district_map(berlin_data),
      y = epot_data,
      by = "bez"
    ) %>%
      dplyr::select(-bez) %>%
      dplyr::rename(district = bezirk) %>%
      dplyr::mutate(is_waterbody = FALSE) %>%
      dplyr::relocate(is_waterbody) %>%
      dplyr::arrange(district)

    # Add default evaporation (district = NA)
    epot_not_waterbody_default <- epot_not_waterbody %>%
      dplyr::summarise(
        etp = as.integer(round(mean(etp))),
        etps = as.integer(round(mean(etps)))
      ) %>% cbind(
        is_waterbody = FALSE,
        district = NA
      )

    # Use old waterbody evaporation (we do not know how to recalculate)
    epot_waterbody <- kwb.abimo::read_config() %>%
      kwb.rabimo::abimo_config_to_config() %>%
      kwb.utils::selectElements("potential_evaporation") %>%
      dplyr::filter(is_waterbody) %>%
      dplyr::arrange(district)

    rbind(
      epot_waterbody,
      epot_not_waterbody,
      epot_not_waterbody_default
    )
  }

  # import green roof data
  download_green_roof_data <- function(layer) {
    data <- URL_GREEN_ROOFS %>%
      sf::read_sf(layer = layer) %>%
      as.data.frame() %>%
      dplyr::select("code" = schluessel, "green_roof" = gruen20_p) %>%
      dplyr::mutate(green_roof = green_roof / 100)
  }
}


# Read data --------------------------------------------------------------------
{
  berlin_data <- dplyr::bind_rows(
    block = read_gdbtable(FILE_BLOCKS),
    road = read_gdbtable(FILE_ROADS),
    .id = "category"
  ) %>%
    as.data.frame()

  # Read evaporation table (generated by inst/scripts/epot-raster-to-district.R)
  epot_data <- readRDS("~/../Downloads/A/abimo/epot_91-20.rds") %>%
    dplyr::select(bez = "ID", etp = total_mean, etps = summer_mean)
}

# Prepare data -----------------------------------------------------------------

# The following is based on what happens inside kwb.rabimo:::prepare_input_data

# Rename columns from ABIMO 3.2 names to new ABIMO-internal names
# The following was created by
# renamings <- kwb.rabimo:::get_column_renamings()
# names(renamings)<-tolower(names(renamings))
# dput(renamings)

data <- kwb.utils::renameColumns(berlin_data, renamings = list(
  code = "code", regenja = "prec_yr", regenso = "prec_s", bezirk = "district",
  probau = "roof", kan_beb = "swg_roof", provgu = "pvd", kan_vgu = "swg_pvd",
  belag1 = "srf1_pvd", belag2 = "srf2_pvd", belag3 = "srf3_pvd",
  belag4 = "srf4_pvd", belag5 = "srf5_pvd", vgstrasse = "pvd_r",
  kan_str = "swg_pvd_r", str_belag1 = "srf1_pvd_r", str_belag2 = "srf2_pvd_r",
  str_belag3 = "srf3_pvd_r", str_belag4 = "srf4_pvd_r", flur = "gw_dist",
  feld_30 = "ufc30", feld_150 = "ufc150", nutzung = "berlin_usage",
  typ = "berlin_type"
))

# Set str_flges to zero
data$str_flges <- 0

# Names of columns representing percentages
# grep("roof|pvd|srf", names(data), value = TRUE)
percentage_cols <- c(
  "roof", "pvd", "srf1_pvd", "srf2_pvd", "srf3_pvd", "srf4_pvd", "pvd_r",
  "swg_roof", "swg_pvd", "swg_pvd_r", "srf1_pvd_r", "srf2_pvd_r", "srf3_pvd_r",
  "srf4_pvd_r", "srf5_pvd"
)

# Replace NA with zero in columns representing percentages
data <- kwb.rabimo:::set_columns_to_zero(
  data = data,
  columns = percentage_cols,
  check = is.na,
  text = "value is NA"
)

# Plausibility check: Were roads correctly identified?
is_road <- data$category == "road"
stopifnot(all(!is_road | grepl("Stra.e", data$art)))

# Check that there is no "usage" type for roads (NAs or zero)
stopifnot(all(is.na(data$berlin_usage[is_road])))

# Set "berlin_usage" for roads to 300
data$berlin_usage[is_road] <- 300L

# Names of columns representing surface class percentages
surface_class_columns <- c(
  "srf1_pvd", "srf2_pvd", "srf3_pvd", "srf4_pvd", "srf5_pvd"
)

# Helper functions
surface_class_sums <- function(df) unname(rowSums(df[surface_class_columns]))
almost_zero <- function(x, tolerance = 1e-8) abs(x) < tolerance

# Scale percentages with sum > 100 down to a sum of 100
too_high <- surface_class_sums(data) > 100
scaling_factors <- 100 / surface_class_sums(data)[too_high]
data[too_high, surface_class_columns] <- scaling_factors *
  data[too_high, surface_class_columns]
stopifnot(all(surface_class_sums(data) <= 100 + 1e-10))

sum_is_zero <- almost_zero(surface_class_sums(data))
sum_is_zero_but_pvd_is_not <- sum_is_zero & !almost_zero(data$pvd)

cat(sprintf(
  "In %d block areas, pvd all fields %s are zero but pvd is not zero:\n%s",
  sum(sum_is_zero_but_pvd_is_not),
  paste(surface_class_columns, collapse = ", "),
  paste(collapse = "\n", sprintf(
    "%s (%s)",
    data$code[sum_is_zero_but_pvd_is_not],
    data$category[sum_is_zero_but_pvd_is_not]
  ))
))

#data$pvd[sum_is_zero_but_pvd_is_not]
#invalid_blocks <- read_gdbtable(FILE_BLOCKS, clear_shape = FALSE) %>%
#  dplyr::filter(code %in% data$code[sum_is_zero_but_pvd_is_not])
#sf::plot_sf(invalid_blocks)

too_low <- surface_class_sums(data) < 100
#barplot(table(surface_class_sums(data[too_low, ])))

data$srf5_pvd[too_low] <- data$srf5_pvd[too_low] + (
  100 - surface_class_sums(data[too_low, ])
)

# All sums should now be (almost) 100
stopifnot(all(almost_zero(surface_class_sums(data) - 100)))

# Apply precipitation correction factor
data$prec_yr <- data$prec_yr * PRECIPITATION_CORRECTION_FACTOR

# add column total_area
data$total_area <- data$flges + data$str_flges
stopifnot(all(almost_zero(data$flalle - data$total_area)))

# add main and road fractions
data$main_frac <- data$flges / data$total_area # should be one
data$road_frac <- data$str_flges / data$total_area # should be zero
stopifnot(all(almost_zero(data$main_frac - 1)))
stopifnot(all(almost_zero(data$road_frac)))

# Convert percentages to fractions
data[percentage_cols] <- lapply(data[percentage_cols], `/`, 100)

# Limit ufc values to 30
data$ufc30 <- pmin(data$ufc30, 30)
data$ufc150 <- pmin(data$ufc150, 30)

# insert "empty" to_swale column (fraction of the area connected to a swale)
data$to_swale <- 0

# Left join green-roof column (fraction of roof)
green_roof_data <- download_green_roof_data(layer = GREEN_ROOF_LAYER)
data <- data %>%
  dplyr::left_join(green_roof_data, by = "code") %>%
  kwb.rabimo:::set_columns_to_zero_where_na(columns = "green_roof")

# Get (land_type, veg_class, irrigation) tuples based on Berlin-specific codes
usage_types <- data[, c("berlin_usage", "berlin_type")]
usages <- do.call(kwb.rabimo::get_usage_tuple, unname(usage_types))

# Calculate potential evaporation for all areas and column-bind everything
# together. Roads have no district: etp 775
potential_evaporation <- kwb.rabimo:::get_potential_evaporation(
  is_waterbody = usages$land_type == "waterbody",
  district = data$district,
  lookup = get_evaporation_config(berlin_data, epot_data)
)

data <- cbind(data, usages, potential_evaporation)

# Add a text column describing the type of block (usage)
data$block_type <- kwb.rabimo:::get_block_type(usage_types)

# Write road specification into "block_type"
stopifnot(identical(is_road, grepl("300", data$block_type)))
data$block_type[is_road] <- "300_road"

# Set roof area that are NAs to 0 for water bodies
is_waterbody_and_roof_is_na <- data$land_type == "waterbody" & is.na(data$roof)
table(is_waterbody_and_roof_is_na)
data$roof[is_waterbody_and_roof_is_na] <- 0

# Select only the required columns and convert data types as required
berlin_data_new <- data %>%
  kwb.utils::selectColumns(
    intersect(kwb.rabimo:::get_column_selection(), names(data))
  ) %>%
  kwb.rabimo:::check_or_convert_data_types(
    kwb.rabimo:::get_expected_data_type(),
    convert = TRUE,
    dbg = TRUE
  )

# Read and modify config -------------------------------------------------------
{
  config <- kwb.utils::removeElements(
    kwb.rabimo::rabimo_inputs_2020$config,
    c("result_digits", "irrigation_to_zero")
  )
}

# Run R-Abimo
if (FALSE) {
  abimo_result <- kwb.rabimo::run_rabimo(berlin_data_new, config = config)
}
